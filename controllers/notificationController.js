const Food = require("../models/foodModel");
const User = require("../models/userModel");
const admin = require("../config/firebase");

/**
 * G·ª≠i notification tr·ª±c ti·∫øp t·ªõi 1 thi·∫øt b·ªã (test nhanh)
 * Body c·∫ßn: { fcmToken, title, body }
 */
exports.sendNotification = async (req, res) => {
    try {
        const { fcmToken, title, body } = req.body;

        if (!fcmToken) {
            return res.status(400).json({ error: "Thi·∫øu fcmToken" });
        }

        const message = {
            token: fcmToken,
            notification: {
                title: title || "Th√¥ng b√°o m·ªõi",
                body: body || "B·∫°n c√≥ m·ªôt tin nh·∫Øn",
            },
        };

        const response = await admin.messaging().send(message);
        console.log("‚úÖ Sent direct notification:", response);

        res.json({ success: true, response });
    } catch (err) {
        console.error("‚ùå sendNotification ERROR:", err.message);
        res.status(500).json({ error: err.message });
    }
};


exports.autoNotifyExpiringFoods = async (req, res) => {
  try {
    console.log("üîî autoNotifyExpiringFoods START");

    const foods = await Food.find({});
    console.log(`üì¶ Found ${foods.length} foods`);

    const now = new Date();
    const userFoodsMap = {};

    for (const food of foods) {
      if (!food.expiryDate) continue;

      const expiry = new Date(food.expiryDate);
      const diffDays = Math.ceil((expiry - now) / (1000 * 60 * 60 * 24));

      if (diffDays <= 2) {
        if (!userFoodsMap[food.userId]) userFoodsMap[food.userId] = [];
        userFoodsMap[food.userId].push({ name: food.name, diffDays });
      }
    }

    let totalNotifies = 0;
    const tokenUserMap = {}; // { fcmToken: user }

    // L·∫•y user + check lastLogin
    for (const userId of Object.keys(userFoodsMap)) {
      const user = await User.findById(userId);
      if (!user?.fcmToken) {
        console.log(`‚ö†Ô∏è User ${userId} has no fcmToken`);
        continue;
      }

      const existing = tokenUserMap[user.fcmToken];
      if (!existing || (user.lastLogin && user.lastLogin > existing.lastLogin)) {
        tokenUserMap[user.fcmToken] = user; // üî• ch·ªçn user c√≥ lastLogin m·ªõi h∆°n
      }
    }

    // G·ª≠i th√¥ng b√°o cho t·ª´ng fcmToken (ch·ªâ user ƒëƒÉng nh·∫≠p sau c√πng)
    for (const [fcmToken, user] of Object.entries(tokenUserMap)) {
      const foodsForUser = userFoodsMap[user._id] || [];
      if (!foodsForUser.length) continue;

      const expiringFoods = foodsForUser
        .filter(f => f.diffDays > 0)
        .map(f => f.name);

      const expiredFoods = foodsForUser
        .filter(f => f.diffDays <= 0)
        .map(f => f.name);

      let foodsListStr = "";
      if (expiringFoods.length > 0) {
        foodsListStr += `Th·ª±c ph·∫©m s·∫Øp h·∫øt h·∫°n: ${expiringFoods.join(", ")}`;
      }
      if (expiredFoods.length > 0) {
        if (foodsListStr) foodsListStr += "\n";
        foodsListStr += `Th·ª±c ph·∫©m qu√° h·∫°n: ${expiredFoods.join(", ")}`;
      }

      if (!foodsListStr) continue;

      const message = {
        token: fcmToken,
        notification: {
          title: "‚ö†Ô∏è C·∫£nh b√°o th·ª±c ph·∫©m",
          body: foodsListStr,
        },
      };

      await admin.messaging().send(message);
      console.log(`‚úÖ Sent notify to user ${user._id} (last login)`);
      totalNotifies++;
    }

    res.json({ success: true, message: `ƒê√£ g·ª≠i ${totalNotifies} th√¥ng b√°o (lastLogin filter)` });
  } catch (err) {
    console.error("‚ùå autoNotifyExpiringFoods ERROR:", err.message);
    res.status(500).json({ error: err.message });
  }
};

// POST /api/notification/set-time
exports.setNotifyTime = async (req, res) => {
  try {
    const { userId, notifyTime } = req.body;

    if (!notifyTime || !/^\d{2}:\d{2}$/.test(notifyTime)) {
      return res.status(400).json({ error: "Gi·ªù kh√¥ng h·ª£p l·ªá (HH:mm)" });
    }

    const user = await User.findByIdAndUpdate(
      userId,
      { notifyTime },
      { new: true }
    );

    if (!user) return res.status(404).json({ error: "User kh√¥ng t·ªìn t·∫°i" });

    res.json({ success: true, notifyTime: user.notifyTime });
  } catch (err) {
    console.error("‚ùå setNotifyTime ERROR:", err.message);
    res.status(500).json({ error: err.message });
  }
};

exports.sendAutoNotifyForUser = async (user) => {
  const foods = await Food.find({ userId: user._id });

  const now = new Date();
  const foodsForUser = [];

  for (const food of foods) {
    if (!food.expiryDate) continue;
    const expiry = new Date(food.expiryDate);
    const diffDays = Math.ceil((expiry - now) / (1000 * 60 * 60 * 24));

    if (diffDays <= 2) {
      foodsForUser.push({ name: food.name, diffDays });
    }
  }

  if (!foodsForUser.length) return;

  const expiringFoods = foodsForUser.filter(f => f.diffDays > 0).map(f => f.name);
  const expiredFoods = foodsForUser.filter(f => f.diffDays <= 0).map(f => f.name);

  let foodsListStr = "";
  if (expiringFoods.length > 0) {
    foodsListStr += `Th·ª±c ph·∫©m s·∫Øp h·∫øt h·∫°n: ${expiringFoods.join(", ")}`;
  }
  if (expiredFoods.length > 0) {
    if (foodsListStr) foodsListStr += "\n";
    foodsListStr += `Th·ª±c ph·∫©m qu√° h·∫°n: ${expiredFoods.join(", ")}`;
  }

  if (!foodsListStr) return;

  const message = {
    token: user.fcmToken,
    notification: {
      title: "‚ö†Ô∏è C·∫£nh b√°o th·ª±c ph·∫©m",
      body: foodsListStr,
    },
  };

  await admin.messaging().send(message);
  console.log(`‚úÖ Sent notify to user ${user._id} at ${user.notifyTime}`);
};
